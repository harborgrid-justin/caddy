//! Audit reporting and alerting
//!
//! Generate reports and trigger alerts for security events.

use crate::enterprise::audit::{
    compliance::ComplianceReport,
    event::{AuditEvent, EventSeverity, EventType},
    query::{AuditQuery, QueryAggregation},
    storage::AuditStorage,
};
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use thiserror::Error;

/// Errors that can occur during reporting
#[derive(Debug, Error)]
pub enum ReportError {
    /// Query error
    #[error("Query error: {0}")]
    Query(#[from] crate::enterprise::audit::query::QueryError),

    /// I/O error
    #[error("I/O error: {0}")]
    Io(#[from] std::io::Error),

    /// Serialization error
    #[error("Serialization error: {0}")]
    Serialization(#[from] serde_json::Error),

    /// Report generation error
    #[error("Report generation error: {0}")]
    Generation(String),
}

/// Result type for reporting operations
pub type Result<T> = std::result::Result<T, ReportError>;

/// Report format
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum ReportFormat {
    /// JSON format
    Json,
    /// CSV format
    Csv,
    /// PDF format (stub)
    Pdf,
    /// HTML format
    Html,
    /// Plain text
    Text,
}

/// Report configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReportConfig {
    /// Report title
    pub title: String,

    /// Report format
    pub format: ReportFormat,

    /// Include summary statistics
    pub include_summary: bool,

    /// Include event details
    pub include_details: bool,

    /// Include charts/visualizations (for HTML/PDF)
    pub include_charts: bool,

    /// Maximum number of events to include
    pub max_events: Option<usize>,
}

impl Default for ReportConfig {
    fn default() -> Self {
        Self {
            title: "Audit Report".to_string(),
            format: ReportFormat::Json,
            include_summary: true,
            include_details: true,
            include_charts: false,
            max_events: None,
        }
    }
}

/// Audit report
#[derive(Debug, Serialize, Deserialize)]
pub struct AuditReport {
    /// Report metadata
    pub metadata: ReportMetadata,

    /// Summary statistics
    pub summary: Option<ReportSummary>,

    /// Event details
    pub events: Vec<AuditEvent>,

    /// Compliance information
    pub compliance: Option<ComplianceReport>,
}

/// Report metadata
#[derive(Debug, Serialize, Deserialize)]
pub struct ReportMetadata {
    /// Report title
    pub title: String,

    /// Generation timestamp
    pub generated_at: DateTime<Utc>,

    /// Report period start
    pub period_start: DateTime<Utc>,

    /// Report period end
    pub period_end: DateTime<Utc>,

    /// Generated by user
    pub generated_by: Option<String>,

    /// Additional metadata
    pub custom_fields: HashMap<String, String>,
}

/// Report summary statistics
#[derive(Debug, Serialize, Deserialize)]
pub struct ReportSummary {
    /// Total number of events
    pub total_events: usize,

    /// Number of successful events
    pub successful_events: usize,

    /// Number of failed events
    pub failed_events: usize,

    /// Success rate (percentage)
    pub success_rate: f64,

    /// Unique users
    pub unique_users: usize,

    /// Unique resources
    pub unique_resources: usize,

    /// Events by action type
    pub by_action: HashMap<String, usize>,

    /// Events by severity
    pub by_severity: HashMap<String, usize>,

    /// Top users by activity
    pub top_users: Vec<(String, usize)>,

    /// Top resources by access
    pub top_resources: Vec<(String, usize)>,
}

/// Report generator
pub struct ReportGenerator;

impl ReportGenerator {
    /// Generate an audit report
    pub async fn generate<S>(
        storage: &S,
        query: AuditQuery,
        config: ReportConfig,
    ) -> Result<AuditReport>
    where
        S: AuditStorage,
    {
        let events = query.execute(storage).await?;

        let metadata = ReportMetadata {
            title: config.title.clone(),
            generated_at: Utc::now(),
            period_start: events.first().map(|e| e.timestamp).unwrap_or_else(Utc::now),
            period_end: events.last().map(|e| e.timestamp).unwrap_or_else(Utc::now),
            generated_by: None,
            custom_fields: HashMap::new(),
        };

        let summary = if config.include_summary {
            Some(Self::generate_summary(&events))
        } else {
            None
        };

        let report_events = if config.include_details {
            if let Some(max) = config.max_events {
                events.into_iter().take(max).collect()
            } else {
                events
            }
        } else {
            Vec::new()
        };

        Ok(AuditReport {
            metadata,
            summary,
            events: report_events,
            compliance: None,
        })
    }

    /// Generate summary statistics
    fn generate_summary(events: &[AuditEvent]) -> ReportSummary {
        let agg = QueryAggregation::new(events.to_vec());

        let total_events = events.len();
        let successful_events = events.iter().filter(|e| e.success).count();
        let failed_events = total_events - successful_events;

        let success_rate = if total_events > 0 {
            (successful_events as f64 / total_events as f64) * 100.0
        } else {
            0.0
        };

        let by_action: HashMap<String, usize> = agg
            .by_action()
            .into_iter()
            .map(|(action, count)| (format!("{:?}", action), count))
            .collect();

        let by_severity: HashMap<String, usize> = agg
            .by_severity()
            .into_iter()
            .map(|(severity, count)| (format!("{:?}", severity), count))
            .collect();

        let top_users = agg.by_user().into_iter().take(10).collect();
        let top_resources = agg.by_resource().into_iter().take(10).collect();

        ReportSummary {
            total_events,
            successful_events,
            failed_events,
            success_rate,
            unique_users: agg.unique_users().len(),
            unique_resources: agg.unique_resources().len(),
            by_action,
            by_severity,
            top_users,
            top_resources,
        }
    }

    /// Export report to JSON
    pub fn to_json(report: &AuditReport) -> Result<String> {
        Ok(serde_json::to_string_pretty(report)?)
    }

    /// Export report to CSV
    pub fn to_csv(report: &AuditReport) -> Result<String> {
        let mut csv = String::new();

        // Header
        csv.push_str("Timestamp,User ID,Action,Resource,Severity,Success,IP Address,Session ID\n");

        // Events
        for event in &report.events {
            csv.push_str(&format!(
                "{},{},{:?},{},{:?},{},{},{}\n",
                event.timestamp.to_rfc3339(),
                event.user_id,
                event.action,
                event.resource,
                event.severity,
                event.success,
                event.ip_address.as_deref().unwrap_or(""),
                event.session_id.as_deref().unwrap_or("")
            ));
        }

        Ok(csv)
    }

    /// Export report to HTML
    pub fn to_html(report: &AuditReport) -> Result<String> {
        let mut html = String::new();

        html.push_str("<!DOCTYPE html>\n<html>\n<head>\n");
        html.push_str(&format!("<title>{}</title>\n", report.metadata.title));
        html.push_str("<style>\n");
        html.push_str("body { font-family: Arial, sans-serif; margin: 20px; }\n");
        html.push_str("table { border-collapse: collapse; width: 100%; margin-top: 20px; }\n");
        html.push_str("th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }\n");
        html.push_str("th { background-color: #4CAF50; color: white; }\n");
        html.push_str("tr:nth-child(even) { background-color: #f2f2f2; }\n");
        html.push_str(".summary { background-color: #e7f3fe; padding: 15px; border-radius: 5px; }\n");
        html.push_str("</style>\n</head>\n<body>\n");

        // Title
        html.push_str(&format!("<h1>{}</h1>\n", report.metadata.title));
        html.push_str(&format!(
            "<p>Generated: {}</p>\n",
            report.metadata.generated_at.to_rfc2822()
        ));

        // Summary
        if let Some(ref summary) = report.summary {
            html.push_str("<div class='summary'>\n<h2>Summary</h2>\n");
            html.push_str(&format!("<p>Total Events: {}</p>\n", summary.total_events));
            html.push_str(&format!(
                "<p>Success Rate: {:.2}%</p>\n",
                summary.success_rate
            ));
            html.push_str(&format!("<p>Unique Users: {}</p>\n", summary.unique_users));
            html.push_str("</div>\n");
        }

        // Events table
        if !report.events.is_empty() {
            html.push_str("<h2>Events</h2>\n");
            html.push_str("<table>\n<tr>\n");
            html.push_str("<th>Timestamp</th><th>User</th><th>Action</th>");
            html.push_str("<th>Resource</th><th>Severity</th><th>Status</th>\n</tr>\n");

            for event in &report.events {
                html.push_str("<tr>\n");
                html.push_str(&format!("<td>{}</td>\n", event.timestamp.format("%Y-%m-%d %H:%M:%S")));
                html.push_str(&format!("<td>{}</td>\n", event.user_id));
                html.push_str(&format!("<td>{:?}</td>\n", event.action));
                html.push_str(&format!("<td>{}</td>\n", event.resource));
                html.push_str(&format!("<td>{:?}</td>\n", event.severity));
                html.push_str(&format!(
                    "<td>{}</td>\n",
                    if event.success { "Success" } else { "Failed" }
                ));
                html.push_str("</tr>\n");
            }

            html.push_str("</table>\n");
        }

        html.push_str("</body>\n</html>");

        Ok(html)
    }

    /// Export report to text
    pub fn to_text(report: &AuditReport) -> Result<String> {
        let mut text = String::new();

        text.push_str(&format!("=== {} ===\n\n", report.metadata.title));
        text.push_str(&format!(
            "Generated: {}\n",
            report.metadata.generated_at.to_rfc2822()
        ));
        text.push_str(&format!(
            "Period: {} to {}\n\n",
            report.metadata.period_start.format("%Y-%m-%d"),
            report.metadata.period_end.format("%Y-%m-%d")
        ));

        if let Some(ref summary) = report.summary {
            text.push_str("SUMMARY\n");
            text.push_str("-------\n");
            text.push_str(&format!("Total Events: {}\n", summary.total_events));
            text.push_str(&format!("Successful: {}\n", summary.successful_events));
            text.push_str(&format!("Failed: {}\n", summary.failed_events));
            text.push_str(&format!("Success Rate: {:.2}%\n", summary.success_rate));
            text.push_str(&format!("Unique Users: {}\n", summary.unique_users));
            text.push_str(&format!("Unique Resources: {}\n\n", summary.unique_resources));
        }

        if !report.events.is_empty() {
            text.push_str("EVENTS\n");
            text.push_str("------\n");
            for event in &report.events {
                text.push_str(&format!(
                    "[{}] {} - {:?} on {} ({})\n",
                    event.timestamp.format("%Y-%m-%d %H:%M:%S"),
                    event.user_id,
                    event.action,
                    event.resource,
                    if event.success { "Success" } else { "Failed" }
                ));
            }
        }

        Ok(text)
    }

    /// Save report to file
    pub async fn save_to_file(
        report: &AuditReport,
        format: ReportFormat,
        path: impl AsRef<std::path::Path>,
    ) -> Result<()> {
        let content = match format {
            ReportFormat::Json => Self::to_json(report)?,
            ReportFormat::Csv => Self::to_csv(report)?,
            ReportFormat::Html => Self::to_html(report)?,
            ReportFormat::Text => Self::to_text(report)?,
            ReportFormat::Pdf => {
                return Err(ReportError::Generation(
                    "PDF generation not yet implemented".to_string(),
                ))
            }
        };

        tokio::fs::write(path, content).await?;
        Ok(())
    }
}

/// Alert configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AlertConfig {
    /// Alert name
    pub name: String,

    /// Event types to monitor
    pub event_types: Vec<EventType>,

    /// Severity levels to alert on
    pub severities: Vec<EventSeverity>,

    /// Alert on failures only
    pub failures_only: bool,

    /// Threshold (number of events in time window)
    pub threshold: usize,

    /// Time window in seconds
    pub time_window_seconds: i64,

    /// Alert destinations (email, webhook, etc.)
    pub destinations: Vec<String>,
}

/// Alert trigger
pub struct AlertTrigger {
    config: AlertConfig,
    event_buffer: Vec<AuditEvent>,
}

impl AlertTrigger {
    /// Create a new alert trigger
    pub fn new(config: AlertConfig) -> Self {
        Self {
            config,
            event_buffer: Vec::new(),
        }
    }

    /// Process an event and check if alert should be triggered
    pub fn process_event(&mut self, event: &AuditEvent) -> bool {
        // Check if event matches criteria
        if !self.matches_criteria(event) {
            return false;
        }

        // Add to buffer
        self.event_buffer.push(event.clone());

        // Remove old events outside time window
        let cutoff = Utc::now()
            - chrono::Duration::seconds(self.config.time_window_seconds);
        self.event_buffer.retain(|e| e.timestamp >= cutoff);

        // Check threshold
        self.event_buffer.len() >= self.config.threshold
    }

    /// Check if event matches alert criteria
    fn matches_criteria(&self, event: &AuditEvent) -> bool {
        // Check event type
        if !self.config.event_types.is_empty()
            && !self.config.event_types.contains(&event.action)
        {
            return false;
        }

        // Check severity
        if !self.config.severities.is_empty()
            && !self.config.severities.contains(&event.severity)
        {
            return false;
        }

        // Check success status
        if self.config.failures_only && event.success {
            return false;
        }

        true
    }

    /// Get events that triggered the alert
    pub fn get_trigger_events(&self) -> &[AuditEvent] {
        &self.event_buffer
    }
}

/// Scheduled report configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ScheduledReport {
    /// Report name
    pub name: String,

    /// Schedule (cron expression)
    pub schedule: String,

    /// Query to run
    pub query_config: QueryConfig,

    /// Report configuration
    pub report_config: ReportConfig,

    /// Delivery destinations
    pub destinations: Vec<String>,
}

/// Query configuration for scheduled reports
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct QueryConfig {
    /// Days to look back
    pub lookback_days: i64,

    /// User IDs to filter
    pub user_ids: Vec<String>,

    /// Action types to filter
    pub actions: Vec<EventType>,

    /// Severity levels to filter
    pub severities: Vec<EventSeverity>,
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::enterprise::audit::event::AuditEvent;
    use crate::enterprise::audit::storage::MemoryStorage;

    #[tokio::test]
    async fn test_report_generation() {
        let mut storage = MemoryStorage::new();

        let event = AuditEvent::builder()
            .user_id("user1")
            .action(EventType::Create)
            .resource("resource1")
            .build();

        storage.store(&event).await.unwrap();

        let query = AuditQuery::new().last_days(1);
        let config = ReportConfig::default();

        let report = ReportGenerator::generate(&storage, query, config)
            .await
            .unwrap();

        assert_eq!(report.events.len(), 1);
        assert!(report.summary.is_some());
    }

    #[tokio::test]
    async fn test_report_formats() {
        let report = AuditReport {
            metadata: ReportMetadata {
                title: "Test Report".to_string(),
                generated_at: Utc::now(),
                period_start: Utc::now(),
                period_end: Utc::now(),
                generated_by: None,
                custom_fields: HashMap::new(),
            },
            summary: None,
            events: vec![],
            compliance: None,
        };

        // Test JSON
        let json = ReportGenerator::to_json(&report).unwrap();
        assert!(json.contains("Test Report"));

        // Test CSV
        let csv = ReportGenerator::to_csv(&report).unwrap();
        assert!(csv.contains("Timestamp"));

        // Test HTML
        let html = ReportGenerator::to_html(&report).unwrap();
        assert!(html.contains("<html>"));

        // Test Text
        let text = ReportGenerator::to_text(&report).unwrap();
        assert!(text.contains("Test Report"));
    }

    #[test]
    fn test_alert_trigger() {
        let config = AlertConfig {
            name: "Test Alert".to_string(),
            event_types: vec![EventType::Login],
            severities: vec![EventSeverity::Security],
            failures_only: true,
            threshold: 3,
            time_window_seconds: 60,
            destinations: vec!["admin@example.com".to_string()],
        };

        let mut trigger = AlertTrigger::new(config);

        let event = AuditEvent::builder()
            .user_id("user1")
            .action(EventType::Login)
            .resource("system")
            .severity(EventSeverity::Security)
            .success(false)
            .build();

        assert!(!trigger.process_event(&event));
        assert!(!trigger.process_event(&event));
        assert!(trigger.process_event(&event)); // Should trigger on 3rd event
    }
}
