//! Compliance reporting and evidence collection
//!
//! This module provides report generation, evidence collection, audit summaries,
//! and export in various formats (PDF, CSV, JSON) for compliance frameworks.

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;
use uuid::Uuid;

/// Report type
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum ReportType {
    /// Audit log summary
    AuditSummary,
    /// Compliance attestation
    ComplianceAttestation,
    /// Access control review
    AccessControl,
    /// Change management
    ChangeManagement,
    /// Incident summary
    IncidentSummary,
    /// GDPR data processing
    GdprProcessing,
    /// SOC 2 evidence
    Soc2Evidence,
    /// HIPAA audit
    HipaaAudit,
    /// Retention policy status
    RetentionStatus,
    /// Custom report
    Custom(u32),
}

/// Report format
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum ReportFormat {
    /// JSON format
    Json,
    /// CSV format
    Csv,
    /// PDF format (simplified representation)
    Pdf,
    /// HTML format
    Html,
    /// Markdown format
    Markdown,
}

/// Report status
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum ReportStatus {
    /// Report generation pending
    Pending,
    /// Report being generated
    Generating,
    /// Report completed successfully
    Completed,
    /// Report generation failed
    Failed,
}

/// Compliance report metadata
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ComplianceReport {
    /// Unique report ID
    pub id: Uuid,

    /// Report type
    pub report_type: ReportType,

    /// Report title
    pub title: String,

    /// Report description
    pub description: String,

    /// Generated timestamp
    pub generated_at: DateTime<Utc>,

    /// Generated by user
    pub generated_by: String,

    /// Report period start
    pub period_start: DateTime<Utc>,

    /// Report period end
    pub period_end: DateTime<Utc>,

    /// Report status
    pub status: ReportStatus,

    /// Report format
    pub format: ReportFormat,

    /// Report content/data
    pub content: String,

    /// Evidence references
    pub evidence: Vec<EvidenceReference>,

    /// Metadata
    pub metadata: HashMap<String, String>,

    /// File path (if saved to disk)
    pub file_path: Option<String>,

    /// Signed by (digital signature)
    pub signed_by: Option<String>,

    /// Signature timestamp
    pub signed_at: Option<DateTime<Utc>>,
}

/// Evidence reference
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EvidenceReference {
    /// Evidence ID
    pub id: Uuid,

    /// Evidence type
    pub evidence_type: String,

    /// Description
    pub description: String,

    /// Reference (file path, URL, etc.)
    pub reference: String,

    /// Collection timestamp
    pub collected_at: DateTime<Utc>,

    /// Hash for integrity verification
    pub hash: Option<String>,
}

/// Report builder
pub struct ReportBuilder {
    report: ComplianceReport,
}

impl ReportBuilder {
    /// Create new report builder
    pub fn new(report_type: ReportType, title: impl Into<String>) -> Self {
        Self {
            report: ComplianceReport {
                id: Uuid::new_v4(),
                report_type,
                title: title.into(),
                description: String::new(),
                generated_at: Utc::now(),
                generated_by: String::new(),
                period_start: Utc::now(),
                period_end: Utc::now(),
                status: ReportStatus::Pending,
                format: ReportFormat::Json,
                content: String::new(),
                evidence: Vec::new(),
                metadata: HashMap::new(),
                file_path: None,
                signed_by: None,
                signed_at: None,
            },
        }
    }

    /// Set description
    pub fn description(mut self, description: impl Into<String>) -> Self {
        self.report.description = description.into();
        self
    }

    /// Set generator
    pub fn generated_by(mut self, user: impl Into<String>) -> Self {
        self.report.generated_by = user.into();
        self
    }

    /// Set report period
    pub fn period(mut self, start: DateTime<Utc>, end: DateTime<Utc>) -> Self {
        self.report.period_start = start;
        self.report.period_end = end;
        self
    }

    /// Set format
    pub fn format(mut self, format: ReportFormat) -> Self {
        self.report.format = format;
        self
    }

    /// Add evidence
    pub fn evidence(mut self, evidence: EvidenceReference) -> Self {
        self.report.evidence.push(evidence);
        self
    }

    /// Add metadata
    pub fn metadata(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
        self.report.metadata.insert(key.into(), value.into());
        self
    }

    /// Set content
    pub fn content(mut self, content: impl Into<String>) -> Self {
        self.report.content = content.into();
        self
    }

    /// Build the report
    pub fn build(mut self) -> ComplianceReport {
        self.report.status = ReportStatus::Completed;
        self.report
    }
}

/// Report template
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReportTemplate {
    /// Template ID
    pub id: Uuid,

    /// Template name
    pub name: String,

    /// Report type
    pub report_type: ReportType,

    /// Template content
    pub template: String,

    /// Required parameters
    pub parameters: Vec<String>,

    /// Default format
    pub default_format: ReportFormat,
}

/// Report scheduler configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReportSchedule {
    /// Schedule ID
    pub id: Uuid,

    /// Schedule name
    pub name: String,

    /// Report type to generate
    pub report_type: ReportType,

    /// Cron expression
    pub cron_expression: String,

    /// Recipients
    pub recipients: Vec<String>,

    /// Format
    pub format: ReportFormat,

    /// Enabled
    pub enabled: bool,

    /// Last run
    pub last_run: Option<DateTime<Utc>>,

    /// Next run
    pub next_run: Option<DateTime<Utc>>,
}

/// Compliance reporting manager
pub struct ReportingManager {
    /// Generated reports
    reports: Arc<RwLock<HashMap<Uuid, ComplianceReport>>>,

    /// Report templates
    templates: Arc<RwLock<HashMap<Uuid, ReportTemplate>>>,

    /// Report schedules
    schedules: Arc<RwLock<HashMap<Uuid, ReportSchedule>>>,
}

impl ReportingManager {
    /// Create new reporting manager
    pub fn new() -> Self {
        Self {
            reports: Arc::new(RwLock::new(HashMap::new())),
            templates: Arc::new(RwLock::new(HashMap::new())),
            schedules: Arc::new(RwLock::new(HashMap::new())),
        }
    }

    // ========================================================================
    // Report Generation
    // ========================================================================

    /// Generate a report
    pub async fn generate_report(&self, builder: ReportBuilder) -> Result<Uuid, String> {
        let report = builder.build();
        let report_id = report.id;

        let mut reports = self.reports.write().await;
        reports.insert(report_id, report);

        Ok(report_id)
    }

    /// Get report by ID
    pub async fn get_report(&self, id: Uuid) -> Option<ComplianceReport> {
        let reports = self.reports.read().await;
        reports.get(&id).cloned()
    }

    /// Get reports by type
    pub async fn get_reports_by_type(&self, report_type: ReportType) -> Vec<ComplianceReport> {
        let reports = self.reports.read().await;
        reports
            .values()
            .filter(|r| r.report_type == report_type)
            .cloned()
            .collect()
    }

    /// Get reports for period
    pub async fn get_reports_for_period(
        &self,
        start: DateTime<Utc>,
        end: DateTime<Utc>,
    ) -> Vec<ComplianceReport> {
        let reports = self.reports.read().await;
        reports
            .values()
            .filter(|r| r.generated_at >= start && r.generated_at <= end)
            .cloned()
            .collect()
    }

    /// Sign a report
    pub async fn sign_report(&self, report_id: Uuid, signer: impl Into<String>) -> Result<(), String> {
        let mut reports = self.reports.write().await;
        if let Some(report) = reports.get_mut(&report_id) {
            report.signed_by = Some(signer.into());
            report.signed_at = Some(Utc::now());
            Ok(())
        } else {
            Err("Report not found".to_string())
        }
    }

    // ========================================================================
    // Report Templates
    // ========================================================================

    /// Add report template
    pub async fn add_template(&self, template: ReportTemplate) -> Result<Uuid, String> {
        let template_id = template.id;
        let mut templates = self.templates.write().await;
        templates.insert(template_id, template);
        Ok(template_id)
    }

    /// Get template
    pub async fn get_template(&self, id: Uuid) -> Option<ReportTemplate> {
        let templates = self.templates.read().await;
        templates.get(&id).cloned()
    }

    /// Get templates by type
    pub async fn get_templates_by_type(&self, report_type: ReportType) -> Vec<ReportTemplate> {
        let templates = self.templates.read().await;
        templates
            .values()
            .filter(|t| t.report_type == report_type)
            .cloned()
            .collect()
    }

    // ========================================================================
    // Report Scheduling
    // ========================================================================

    /// Add report schedule
    pub async fn add_schedule(&self, schedule: ReportSchedule) -> Result<Uuid, String> {
        let schedule_id = schedule.id;
        let mut schedules = self.schedules.write().await;
        schedules.insert(schedule_id, schedule);
        Ok(schedule_id)
    }

    /// Update schedule
    pub async fn update_schedule(&self, id: Uuid, schedule: ReportSchedule) -> Result<(), String> {
        let mut schedules = self.schedules.write().await;
        schedules.insert(id, schedule);
        Ok(())
    }

    /// Get schedule
    pub async fn get_schedule(&self, id: Uuid) -> Option<ReportSchedule> {
        let schedules = self.schedules.read().await;
        schedules.get(&id).cloned()
    }

    /// Get enabled schedules
    pub async fn get_enabled_schedules(&self) -> Vec<ReportSchedule> {
        let schedules = self.schedules.read().await;
        schedules
            .values()
            .filter(|s| s.enabled)
            .cloned()
            .collect()
    }

    // ========================================================================
    // Export Functions
    // ========================================================================

    /// Export report to JSON
    pub async fn export_to_json(&self, report_id: Uuid) -> Result<String, String> {
        let reports = self.reports.read().await;
        if let Some(report) = reports.get(&report_id) {
            serde_json::to_string_pretty(report).map_err(|e| e.to_string())
        } else {
            Err("Report not found".to_string())
        }
    }

    /// Export report to CSV
    pub async fn export_to_csv(&self, report_id: Uuid) -> Result<String, String> {
        let reports = self.reports.read().await;
        if let Some(report) = reports.get(&report_id) {
            // Simple CSV export - in production use a proper CSV library
            let mut csv = String::new();
            csv.push_str("Field,Value\n");
            csv.push_str(&format!("Report ID,{}\n", report.id));
            csv.push_str(&format!("Title,{}\n", report.title));
            csv.push_str(&format!("Generated At,{}\n", report.generated_at));
            csv.push_str(&format!("Generated By,{}\n", report.generated_by));
            csv.push_str(&format!("Period,{} to {}\n", report.period_start, report.period_end));
            csv.push_str(&format!("Status,{:?}\n", report.status));
            Ok(csv)
        } else {
            Err("Report not found".to_string())
        }
    }

    /// Export report to Markdown
    pub async fn export_to_markdown(&self, report_id: Uuid) -> Result<String, String> {
        let reports = self.reports.read().await;
        if let Some(report) = reports.get(&report_id) {
            let mut md = String::new();
            md.push_str(&format!("# {}\n\n", report.title));
            md.push_str(&format!("**Generated:** {}\n\n", report.generated_at));
            md.push_str(&format!("**Generated By:** {}\n\n", report.generated_by));
            md.push_str(&format!("**Period:** {} to {}\n\n", report.period_start, report.period_end));

            if !report.description.is_empty() {
                md.push_str(&format!("## Description\n\n{}\n\n", report.description));
            }

            md.push_str("## Content\n\n");
            md.push_str(&report.content);
            md.push_str("\n\n");

            if !report.evidence.is_empty() {
                md.push_str("## Evidence\n\n");
                for (i, evidence) in report.evidence.iter().enumerate() {
                    md.push_str(&format!("{}. {} - {}\n", i + 1, evidence.description, evidence.reference));
                }
                md.push_str("\n");
            }

            if let Some(ref signer) = report.signed_by {
                md.push_str(&format!("\n---\n\n**Signed by:** {} at {}\n",
                    signer,
                    report.signed_at.unwrap_or(Utc::now())
                ));
            }

            Ok(md)
        } else {
            Err("Report not found".to_string())
        }
    }

    /// Generate audit summary report
    pub async fn generate_audit_summary(
        &self,
        start: DateTime<Utc>,
        end: DateTime<Utc>,
        data: serde_json::Value,
    ) -> Result<Uuid, String> {
        let content = serde_json::to_string_pretty(&data).map_err(|e| e.to_string())?;

        let builder = ReportBuilder::new(ReportType::AuditSummary, "Audit Summary Report")
            .description("Summary of audit events for the specified period")
            .period(start, end)
            .format(ReportFormat::Json)
            .content(content)
            .generated_by("system");

        self.generate_report(builder).await
    }

    /// Generate compliance attestation report
    pub async fn generate_compliance_attestation(
        &self,
        framework: &str,
        start: DateTime<Utc>,
        end: DateTime<Utc>,
        controls: serde_json::Value,
    ) -> Result<Uuid, String> {
        let content = serde_json::json!({
            "framework": framework,
            "period": {
                "start": start,
                "end": end,
            },
            "controls": controls,
            "attestation": {
                "compliant": true,
                "exceptions": [],
                "notes": "All controls operating effectively",
            }
        });

        let builder = ReportBuilder::new(
            ReportType::ComplianceAttestation,
            format!("{} Compliance Attestation", framework),
        )
        .description(format!("Attestation of compliance with {} framework", framework))
        .period(start, end)
        .format(ReportFormat::Json)
        .content(serde_json::to_string_pretty(&content).unwrap())
        .metadata("framework", framework)
        .generated_by("compliance_officer");

        self.generate_report(builder).await
    }

    /// Generate access control review report
    pub async fn generate_access_control_report(
        &self,
        users: serde_json::Value,
    ) -> Result<Uuid, String> {
        let content = serde_json::json!({
            "review_date": Utc::now(),
            "users": users,
            "findings": [],
            "recommendations": [],
        });

        let builder = ReportBuilder::new(ReportType::AccessControl, "Access Control Review")
            .description("Periodic review of user access and permissions")
            .format(ReportFormat::Json)
            .content(serde_json::to_string_pretty(&content).unwrap())
            .generated_by("security_team");

        self.generate_report(builder).await
    }

    /// Delete old reports
    pub async fn cleanup_old_reports(&self, older_than: DateTime<Utc>) -> Result<u32, String> {
        let mut reports = self.reports.write().await;
        let initial_count = reports.len();

        reports.retain(|_, report| report.generated_at >= older_than);

        let deleted = initial_count - reports.len();
        Ok(deleted as u32)
    }
}

impl Default for ReportingManager {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_report_generation() {
        let manager = ReportingManager::new();

        let builder = ReportBuilder::new(ReportType::AuditSummary, "Test Report")
            .description("Test description")
            .generated_by("test_user")
            .format(ReportFormat::Json)
            .content(r#"{"test": "data"}"#);

        let report_id = manager.generate_report(builder).await.unwrap();
        let report = manager.get_report(report_id).await.unwrap();

        assert_eq!(report.title, "Test Report");
        assert_eq!(report.generated_by, "test_user");
        assert_eq!(report.status, ReportStatus::Completed);
    }

    #[tokio::test]
    async fn test_report_signing() {
        let manager = ReportingManager::new();

        let builder = ReportBuilder::new(ReportType::ComplianceAttestation, "Attestation Report")
            .generated_by("system");

        let report_id = manager.generate_report(builder).await.unwrap();
        manager.sign_report(report_id, "compliance_officer").await.unwrap();

        let report = manager.get_report(report_id).await.unwrap();
        assert_eq!(report.signed_by, Some("compliance_officer".to_string()));
        assert!(report.signed_at.is_some());
    }

    #[tokio::test]
    async fn test_export_formats() {
        let manager = ReportingManager::new();

        let builder = ReportBuilder::new(ReportType::AuditSummary, "Export Test")
            .description("Testing export formats")
            .content("Test content");

        let report_id = manager.generate_report(builder).await.unwrap();

        let json = manager.export_to_json(report_id).await.unwrap();
        assert!(json.contains("Export Test"));

        let csv = manager.export_to_csv(report_id).await.unwrap();
        assert!(csv.contains("Export Test"));

        let markdown = manager.export_to_markdown(report_id).await.unwrap();
        assert!(markdown.contains("# Export Test"));
    }

    #[tokio::test]
    async fn test_report_templates() {
        let manager = ReportingManager::new();

        let template = ReportTemplate {
            id: Uuid::new_v4(),
            name: "Monthly Audit".to_string(),
            report_type: ReportType::AuditSummary,
            template: "Monthly audit template".to_string(),
            parameters: vec!["month".to_string(), "year".to_string()],
            default_format: ReportFormat::Pdf,
        };

        let template_id = manager.add_template(template).await.unwrap();
        let retrieved = manager.get_template(template_id).await.unwrap();

        assert_eq!(retrieved.name, "Monthly Audit");
    }

    #[tokio::test]
    async fn test_report_scheduling() {
        let manager = ReportingManager::new();

        let schedule = ReportSchedule {
            id: Uuid::new_v4(),
            name: "Weekly Audit Report".to_string(),
            report_type: ReportType::AuditSummary,
            cron_expression: "0 0 * * 1".to_string(),
            recipients: vec!["admin@example.com".to_string()],
            format: ReportFormat::Pdf,
            enabled: true,
            last_run: None,
            next_run: None,
        };

        let schedule_id = manager.add_schedule(schedule).await.unwrap();
        let enabled = manager.get_enabled_schedules().await;

        assert_eq!(enabled.len(), 1);
        assert_eq!(enabled[0].id, schedule_id);
    }

    #[tokio::test]
    async fn test_cleanup_old_reports() {
        let manager = ReportingManager::new();

        // Generate an old report
        let old_builder = ReportBuilder::new(ReportType::AuditSummary, "Old Report")
            .content("old");
        manager.generate_report(old_builder).await.unwrap();

        // Cleanup reports older than now (should delete the one we just created)
        let deleted = manager.cleanup_old_reports(Utc::now() + chrono::Duration::seconds(1)).await.unwrap();
        assert_eq!(deleted, 1);
    }
}
